#!/usr/bin/env bash
#
# Simple SecurityGroup report
#

##############################################################################
# Shell Behaviour
##############################################################################

# Check for unbound variables being used
# set -o nounset

# Exit is a bad command is attempted. If you're going to handle errors then
# leave this disabled
# set -o errexit

# Exit if any of the commands in a pipeline exit with a non-zero exit code
# set -o pipefail

##############################################################################
# Variables
##############################################################################

CONST_COMMAND_LINE="$@"
CONST_OS_VERSION=$(uname -r)
CONST_SYSTEM_TYPE=$(uname -m)
CONST_SCRIPT_NAME=${0##*/}

# The PROJECT_ROOT is TWO level up from where the scripts run in the
# 'bin/subcommands' directory
PROJECT_ROOT=$( cd "$( dirname "${BASH_SOURCE[0]}" )/../../" && pwd )

# Load the Frameverk
. ${PROJECT_ROOT}/etc/axerc

# Current logging config
TTY_OUTPUT_ENABLED=$TRUE
LOG_OUTPUT_ENABLED=$TRUE
SYSLOG_OUTPUT_ENABLED=$FALSE
EVENT_OUTPUT_ENABLED=$TRUE
export TTY_OUTPUT_ENABLED LOG_OUTPUT_ENABLED SYSLOG_OUTPUT_ENABLED EVENT_OUTPUT_ENABLED

# Default log file
DEFAULT_OUT="${PROJECT_ROOT}/log/${CONST_SCRIPT_NAME}.log"
# Define somewhere for specific log messages to go
EVENT_LOG="${PROJECT_ROOT}/log/${CONST_SCRIPT_NAME}_events.log"
export DEFAULT_OUT EVENT_LOG

# Trap  abnormal termination
trap cleanup 1 2 3 15

FILTER_ROOT="${PROJECT_ROOT}/etc/filters.d"

##############################################################################
# Functions
##############################################################################

show_usage() {
    cat <<EOF
usage: $CONST_SCRIPT_NAME [--help] <resource> [-f <FORMAT>]
       $CONST_SCRIPT_NAME ec2
       $CONST_SCRIPT_NAME elb -f pipe

The output format can be changed by using one of the supported formats:

plain, simple, grid, fancy_grid, pipe, orgtbl, rst, mediawiki, html, latex,
latex_booktabs, tsv (default: simple)

EOF
}


cleanup() {
    echo "Exiting."
    exit 1
}


_generate() {
    eval "aws ${output_generator}" \
    | xargs -i aws ${awscli_cmd} --output=json \
    | jq --monochrome-output -s '.'
}


_filter() {
    cat \
    | jq --monochrome-output --from-file "${filter_path}" \
    | jq --monochrome-output -s '.'
}


_tabulate() {
    cat \
    | json2orderedtable -f "${output_format}" -s "${output_sort_keys}"
}



# show help for no arguments if stdin is a terminal
if [ "$1" == '-h' ] || [ "$1" == '--help' ] || [ "$1" == 'help' ]
then
    show_usage
    exit 0
fi

resource_name=${1}
output_format="${3:-simple}"


##############################################################################
# Main Script
##############################################################################

filter_path=

# Check for a valid filter in both AXE and in the users' config
if [ -f "${FILTER_ROOT}/${resource_name}.jqf" ]; then
    filter_path="${FILTER_ROOT}/${resource_name}.jqf"
fi

if [ -f "${HOME}/.axe/filters/${resource_name}.jqf" ]; then
    filter_path="${HOME}/.axe/filters/${resource_name}.jqf"
fi

if [ -z ${filter_path} ]; then
    _log "$LINENO" "No filter defined for that resource. Check your available filters"
    exit 1
fi

# Extract the subcommand for the awscli
awscli_cmd="$(grep '^#cmd:' "${filter_path}" | head -1 | awk -F':' '{print $2}')"

# Extract the sort order if present
output_sort_keys="$(grep '^#sort:' "${filter_path}" | head -1 | awk -F':' '{print $2}')"

# Extract the generator if present
output_generator="$(grep '^#foreach:' "${filter_path}" | head -1 | sed -e 's/^#foreach://g')"

# Use the generator if one is configured, otherwise fallback to default filter
# and tabulate processing
if [[ "" != "${output_generator}" ]]; then

    _generate | _filter | _tabulate

else

    aws ${awscli_cmd} --output=json | _filter | _tabulate

fi

#!/usr/bin/env bash
#
# Simple Inventory report
#

##############################################################################
# Shell Behaviour
##############################################################################

# Check for unbound variables being used
# set -o nounset

# Exit is a bad command is attempted. If you're going to handle errors then
# leave this disabled
# set -o errexit

# Exit if any of the commands in a pipeline exit with a non-zero exit code
# set -o pipefail

##############################################################################
# Variables
##############################################################################

CONST_COMMAND_LINE="$@"
CONST_OS_VERSION=$(uname -r)
CONST_SYSTEM_TYPE=$(uname -m)
CONST_SCRIPT_NAME=${0##*/}

# The PROJECT_ROOT is TWO level up from where the scripts run in the
# 'bin/subcommands' directory
PROJECT_ROOT=$( cd "$( dirname "${BASH_SOURCE[0]}" )/../../" && pwd )

# Load the Frameverk
. ${PROJECT_ROOT}/etc/axerc

# Current logging config
TTY_OUTPUT_ENABLED=$TRUE
LOG_OUTPUT_ENABLED=$TRUE
SYSLOG_OUTPUT_ENABLED=$FALSE
EVENT_OUTPUT_ENABLED=$TRUE
export TTY_OUTPUT_ENABLED LOG_OUTPUT_ENABLED SYSLOG_OUTPUT_ENABLED EVENT_OUTPUT_ENABLED

# Default log file
DEFAULT_OUT="${PROJECT_ROOT}/log/${CONST_SCRIPT_NAME}.log"
# Define somewhere for specific log messages to go
EVENT_LOG="${PROJECT_ROOT}/log/${CONST_SCRIPT_NAME}_events.log"
export DEFAULT_OUT EVENT_LOG

# Trap  abnormal termination
trap cleanup 1 2 3 15

output_format="${2:-simple}"

##############################################################################
# Functions
##############################################################################

show_usage() {
    cat <<EOF
usage: $CONST_SCRIPT_NAME [--help] [-f <FORMAT>]

The output format can be changed by using one of the supported formats:

plain, simple, grid, fancy_grid, pipe, orgtbl, rst, mediawiki, html, latex,
latex_booktabs, tsv (default: simple)

EOF
}


cleanup() {
    echo "Exiting."
    exit 1
}


repeat() {
    local input="$1"
    local count="$2"
    myString="$(printf "%${count}s")"
    echo "${myString// /$input}"
}


title() {
    echo "$(echo "${1}" | tr '[:lower:]' '[:upper:]' | sed -e "s/\-/ /g" -e "s/\_/ /g")"
}


# Format specific header
fs_page_header() {
    local fs_header="${AXE_ROOT}/etc/report.d/${output_format}/page_header"
    [ -f "${fs_header}" ] && . "${fs_header}"
}


# Format specific footer
fs_page_footer() {
    local fs_footer="${AXE_ROOT}/etc/report.d/${output_format}/page_footer"
    [ -f "${fs_footer}" ] && . "${fs_footer}"
}


# Format specific headings
fs_heading() {
    local level=$1
    local val="${2}"
    case ${output_format} in
        pipe)
            echo -e "\n$(repeat "#" ${level}) $(title "${val}")\n"
            ;;
        html)
            let level=level+1
            echo -e "\n<h${level}>$(title "${val}")</h${level}>\n"
            ;;
        *)
            echo -e "\n$(title "${val}")\n"
            ;;
    esac
}


# show help for no arguments if stdin is a terminal
if [ "$1" == '-h' ] || [ "$1" == '--help' ] || [ "$1" == 'help' ]
then
    show_usage
    exit 0
fi

##############################################################################
# Main Script
##############################################################################

# These variables will be visible to the header and footer page templates
aws_account_id="$(axe whoami -f pipe | tail -1 | awk -F '|' '{print $2}' | tr -d '[:space:]')"
aws_user="$(axe whoami -f pipe | tail -1 | awk -F '|' '{print $4}' | tr -d '[:space:]')"

fs_page_header

buffer="$(mktemp)"
for resource in $(axe list -c); do
    fs_heading 2 "${resource}"
    axe list "${resource}" -f "${output_format}" > "${buffer}" 2> /dev/null
    if [ $? -eq 0 ]; then
        cat "${buffer}"
    else
        echo "None found"
    fi
done

fs_page_footer

#!/usr/bin/env python

'''
Simple script that attempts to be Cloudformation-Lite by creating instance
resources if they do not already exist on AWS.

While the VPC-ID is not specifically needed in order to deploy an instance
(only the subnet is) it acts as a measure against stupidity by limiting the
damage to a specific environment (VPC)

Usage:
    axe-instance-create -e <env-dir> (-v <vpc-name>|-V <vpc-id>) [options]
    axe-instance-create ( -h | --help )

Options:
    -c <cb-root>, --cb-root=<cb-root>
                          The $CLOUDBUILDER_ROOT defaults to ~/.cloudbuilder but
                          can be overridden if required. [default: ~/.cloudbuilder]
    -e <env-dir>, --envname=<env-dir>
                          Environment directory for inputs and outputs relative
                          to $CLOUDBUILDER_ROOT including a stack_config.yaml
                          which will contain tags, subnets and more
    -v <vpc-name>, --vpc-name=<vpc-name>
                          The vpc-name will be detected from the 'Name' tag
    -V <vpc-id>, --vpc-id=<vpc-id>
    -y, --yes             Actually do anything. Otherwise runs in dry-run mode
    -h, --help            show this help message and exit
    --debug               More verbose (usually debug) logging and output

'''

# TODO: Add option to spin up instances simultaneously
from future.utils import iteritems

import os
import docopt
import axeutils
from axeutils.logger import AxeLog
from axeutils.config import get_config_from_file
from axeutils import check_imports, clean_up
from axeutils.aws import mapper
from axeutils import add_tag_pair

###############################################################################
# CONFIG - Begin
###############################################################################

CONST_MIN_BOTO_VERSION = '2.10.0'
CONST_DIR_TMP = "/tmp"
CONST_LOG_FORMAT_FILE = '%(asctime)s %(levelname)-5.5s %(module)s:%(lineno)04.4d %(funcName)-25.25s %(message)s'
CONST_LOG_FORMAT_CONSOLE = '%(asctime)s %(lineno)04.4d %(levelname)-5.5s %(message)s'
CONST_AXE_ROOT = os.getenv('AXE_ROOT', '')
CONST_CB_ROOT = os.getenv('CLOUDBUILDER_ROOT', None)
DEFAULT_ENV_DIR = '/tmp'

###############################################################################
# CONFIG - End (Do Not Edit Below)
###############################################################################

_log = AxeLog(__file__)
check_imports()

import boto

# We'll use module level variables for the AWS connections to avoid
# reconnecting to AWS every time we need to do something

_mAWS_VPC_CONN = None
_mAWS_EC2_CONN = None
_mAWS_IAM_CONN = None

_mEC2_PARAMS = None
_mLUT_SUBNETS = None
_mLUT_INSTANCES = None
_mLUT_SECURITY_GROUPS = None

_cCOL_HOST_PREFIX = 'HostName_Prefix'
_cCOL_SUBNET_NAME = 'Subnet_Name'
_cCOL_HOST_SUFFIX = 'Host_Suffix'
_cCOL_INSTANCE_TYPE = 'Type'
_cCOL_INSTANCE_COUNT = 'Count'
_cCOL_AMI_ID = 'AMI_ID'
_cCOL_IAM_ROLE = 'IAM_Role'
_cCOL_SECURITY_GROUPS = 'Security_Groups'
_cCOL_PUBLIC_IP_ASSIGN = 'Assign_Pub'
_cCOL_NOTES = 'Notes'
_cCOL_ELB_POOL = 'ELB_Pool'
_cCOL_DNS_ENTRY = 'Route53_DNS'
_cCOL_USER_DATA = 'User_Data'

###############################################################################
# Classes
###############################################################################


class AWSInstance():
    '''Dummy class for attaching instance properties to'''
    pass

###############################################################################
# Functions
###############################################################################


def _validate_vpc(m, subnet_names=[], sg_names=[], ami_ids=[], iam_roles=[]):
    """Validates if all of the Subnets, SGs and AMIs  specified are available
    from the current AWS credentials and in the VPC object"""

    # Validate subnets after reducing to unique values
    _log.info('Searching for configured subnets')
    subnet_names = list(set(subnet_names))
    valid_results = [m.subnet_name_to_id(x) for x in subnet_names if m.subnet_name_to_id(x) is not None]
    invalid_entries = [x for x in subnet_names if m.subnet_name_to_id(x) is None]
    subnets_are_valid = True if len(subnet_names) == len(valid_results) else False
    if subnets_are_valid is False:
        _log.error('The following subnets were invalid: {}'.format(invalid_entries))

    # Validate SGs after reducing to unique values
    _log.info('Searching for configured SecurityGroups')
    sg_names = list(set([sg for sglist in sg_names for sg in sglist]))
    valid_results = [m.sg_name_to_id(x) for x in sg_names if m.sg_name_to_id(x) is not None]
    invalid_entries = [x for x in sg_names if m.sg_name_to_id(x) is None]
    sgs_are_valid = True if len(sg_names) == len(valid_results) else False
    if sgs_are_valid is False:
        _log.error('The following SGs were invalid: {}'.format(invalid_entries))

    # Validate subnets after reducing to unique values
    _log.info('Searching for configured IAM Roles')
    iam_roles = [x for x in iam_roles if x != '']
    iam_roles = list(set(iam_roles))
    iam_role_list = m.get_resources()['iam'].list_roles()
    iam_role_list = [x.role_name for x in iam_role_list.roles]

    roles_are_valid = True if set(iam_roles).issubset(set(iam_role_list)) else False
    if roles_are_valid is False:
        _log.error('The following IAM Roles were invalid: {}'.format(list(set(iam_roles) - set(iam_role_list))))

    # Return the combined result of all the checks
    return subnets_are_valid & sgs_are_valid & roles_are_valid


def _update_dns(m, i, record, record_type='CNAME', ttl=300):
    '''Updates Route53 to create a CNAME record in the dns_suffix Route53 that
    points to the AWS dns entry. This allows the DNS resolution to resolve to
    the public IP when resolution happens from outside AWS, while resolving to
    the VPC internal IP when resolved from within the VPC itself'''

    fqdn = i.name
    hostname, _, dns_suffix = fqdn.partition('.')
    r53 = m.get_resources()['route53']

    try:
        zone_id = r53.get_hosted_zone_by_name(dns_suffix)
    except DNSServerError:
        _log.error('Route53 DNS Zone {} was not found. Ensure Zone exists before provisioning'.format(dns_suffix))
        clean_up(-1)

    _log.debug('Preparing CNAME record for {} in Zone:{} '.format(n, zone_id, dns_suffix))
    changes = boto.route53.record.ResourceRecordSets(
        connection=r53,
        hosted_zone_id=zone_id
    )

    change_dns_update = changes.add_change('UPSERT', dns_suffix, record_type, ttl)
    change_dns_update.add_value(fqdn)

    _log.info('Committing change to DNS')
    try:
        commit = changes.commit()
        _log.debug('{}}'.format(commit))
    except:
        _log.error("Changes can't be made: {}}".format(commit))
        clean_up(-1)


def _get_instances(m, i, dns_suffix=None):
    '''Builds a list of AWSInstance objects representing what the instance names
    should be given several input options for the provided environment'''

    global _cCOL_HOST_PREFIX
    global _cCOL_SUBNET_NAME
    global _cCOL_HOST_SUFFIX
    global _cCOL_INSTANCE_TYPE
    global _cCOL_INSTANCE_COUNT
    global _cCOL_AMI_ID
    global _cCOL_IAM_ROLE
    global _cCOL_SECURITY_GROUPS
    global _cCOL_PUBLIC_IP_ASSIGN
    global _cCOL_NOTES
    global _cCOL_ELB_POOL

    dns_suffix = '.{}'.format(dns_suffix) if dns_suffix is not None else ''

    _log.debug('Creating instance names from {}'.format(i))
    vms = []
    for idx in range(1, int(i[_cCOL_INSTANCE_COUNT])+1):
        vm = AWSInstance()
        prefix = i[_cCOL_HOST_PREFIX]
        # Prepare possible suffixes
        suffixes = {}
        az_marker = '{}'.format(m.subnet_name_to_subnet(i[_cCOL_SUBNET_NAME]).availability_zone).lower()[-1:]
        suffixes['az'] = '-{}'.format(az_marker)
        suffixes['count'] = '-{0:02d}'.format(idx)
        suffixes['both'] = '-{0:02d}{az}'.format(idx, az=az_marker)
        suffixes['none'] = ''
        vm.name = '{}{}{}'.format(prefix, suffixes[i[_cCOL_HOST_SUFFIX].lower()], dns_suffix)
        vm.subnet_id = m.subnet_name_to_id(i[_cCOL_SUBNET_NAME])
        vm.options = i
        vms.append(vm)

    return vms


def _provision_instances(m, instance_list, options=None, dns_suffix=None, keyname=None):
    '''Attempts to provision any instances in the provided list, assuming they
    don't already exist in addition to assigning SGs to instances once created'''

    # Discover what's already in the target VPC
    _log.info('Retrieving existing Instance information')
    reservations = m.get_resources()['ec2'].get_all_reservations()
    provisioned_instances = [i for r in reservations for i in r.instances if i.vpc_id == options['--vpc-id']]
    _log.info('Discovered {0} instances in the VPC'.format(len(provisioned_instances)))

    # Now build a mapping table of name to id
    existing_instances = []
    for i in provisioned_instances:
        try:
            vm = AWSInstance()
            vm.name = str(i.tags['Name'])
            vm.subnet_id = i.subnet_id
        except KeyError:
            _log.warning('Found an instance [{0}] with no Name tag'.format(i.id))
            continue

        existing_instances.append(vm)

    instances_for_provisioning = []
    for i in instance_list:
        instances_for_provisioning.extend(_get_instances(m, i, dns_suffix=dns_suffix))

    _log.debug('Instances to provision')
    already_provisioned = []
    for x in instances_for_provisioning:
        for y in existing_instances:
            if (x.name == y.name and x.subnet_id == y.subnet_id):
                _log.warn('Instance {} already provisioned in subnet {}'.format(x.name, x.subnet_id))
                already_provisioned.append(x)

    instances_for_provisioning = [x for x in instances_for_provisioning if x not in already_provisioned]
    _log.info('We have {} instances to provision'.format(len(instances_for_provisioning)))

    if len(instances_for_provisioning) > 0:

        params_filename = '{}/{}/stack_config.yaml'.format(options['--cb-root'], options['--envname'])
        _log.info('Reading VPC configuration from {0}'.format(params_filename))
        params = get_config_from_file(params_filename)

        tags = []
        _log.info('Searching for default tags in {0}'.format(params_filename))
        for kvp in params['default_tags']:
            for k, v in kvp.items():
                tags = add_tag_pair(tags, k, v)

        _log.info('Searching for instance tags in {0}'.format(params_filename))
        for kvp in params['instance_tags']:
            for k, v in kvp.items():
                tags = add_tag_pair(tags, k, v)

        _log.info('Read {} tags from file'.format(len(tags)))

        # Now we can provision the necessary instances
        successful_results = 0
        for i in instances_for_provisioning:
            result = _provision_instance(
                m,
                i,
                options=options,
                keyname=keyname,
                tags=tags
            )
            successful_results += 1 if result is True else 0

        return successful_results

    _log.warn('Nothing to do')
    return 0


def _provision_instance(m, i, options=None, keyname=None, tags=[]):
    """Attempts to provision an AWS instance with the specified params into the
    current VPC using the provided name for the instance 'Name' tag"""

    _log.debug('Attempting to provision instance {0}'.format(vars(i)))

    # Attribute setup with defaults to handle case where no value/column is
    # defined in the markdown source
    ami_id = i.options.get(_cCOL_AMI_ID, '')
    key_name = keyname
    instance_type = i.options.get(_cCOL_INSTANCE_TYPE, '')
    notes = i.options.get(_cCOL_NOTES, '')
    elb_pool_value = i.options.get(_cCOL_ELB_POOL, None)
    elb_pool = None if elb_pool_value == '' else elb_pool_value
    iam_role = i.options.get(_cCOL_IAM_ROLE, '')
    assign_eip = axeutils.str2bool(i.options.get(_cCOL_PUBLIC_IP_ASSIGN, ''))
    provision_dns = axeutils.str2bool(i.options.get(_cCOL_DNS_ENTRY, ''))
    user_data_value = i.options.get(_cCOL_USER_DATA, None)
    user_data = None if user_data_value == '' else user_data_value
    name = i.name
    subnet_id = i.subnet_id
    subnet_name = i.options.get(_cCOL_SUBNET_NAME, '')

    ec2_conn = m.get_resources()['ec2']

    _log.info('Mapped subnet name [{0}] to [{1}]'.format(subnet_name, subnet_id))

    sg_names = i.options.get(_cCOL_SECURITY_GROUPS, '')
    sg_names = [sg.lstrip().rstrip() for sg in sg_names]
    security_group_ids = [m.sg_name_to_id(x) for x in sg_names if x != '']
    _log.info('Mapped SG name(s) {0} to {1}'.format(sg_names, security_group_ids))

    # Check if we have a userdata file to attach to the instance
    if user_data is not None:
        template_filename = '{}/{}/{}'.format(options['--cb-root'], options['--envname'], user_data)
        from os.path import expanduser
        template_filename = expanduser(template_filename)
        _log.info('A file for user_data was provided: {}'.format(template_filename))
        user_data = open(template_filename, 'r').read()

        # Replace support AXE variables in the bootstrap user-data
        #   AXE_SERVER_NAME
        #   AXE_SERVER_FQDN
        server_fqdn = i.name
        server_hostname, _, server_dns_suffix = server_fqdn.partition('.')
        user_data = user_data.replace('%AXE_SERVER_NAME%', server_hostname)
        user_data = user_data.replace('%AXE_SERVER_FQDN%', server_fqdn)

    # Build and EC2 network interface with SGs attached
    interface = boto.ec2.networkinterface.NetworkInterfaceSpecification(
        subnet_id=subnet_id,
        groups=security_group_ids,
        associate_public_ip_address=assign_eip
    )

    interfaces = boto.ec2.networkinterface.NetworkInterfaceCollection(interface)
    tags = {d['Key']: d['Value'] for d in tags}

    if options['--yes'] is True:

        res = ec2_conn.run_instances(
            ami_id,
            key_name=key_name,
            instance_type=instance_type,
            user_data=user_data,
            network_interfaces=interfaces,
            instance_profile_name=iam_role
        )

        instance = res.instances[0]

        _log.info('Waiting for {0} [{1}] to start ...'.format(name, instance.id))
        axeutils.wait_while(instance, 'pending')

        _log.info('Tagging instance with Name, Notes')
        ec2_conn.create_tags([instance.id], {'Name': name})
        ec2_conn.create_tags([instance.id], {_cCOL_NOTES: notes})

        if elb_pool is not None:
            _log.info('Tagging instance with ELB_POOL')
            ec2_conn.create_tags([instance.id], {'ELB_POOL': elb_pool})

        _log.info('Adding tags')
        for k, v in iteritems(tags):
            _log.debug('Adding tag [{0}] = {1}'.format(k.replace('_', '', 1), v))
            ec2_conn.create_tags([instance.id], {k.replace('_', '', 1): v})

        _log.info('Instance {0} [{1}] now running and tagged'.format(name, instance.id))

        # Provision DNS if enabled
        # if provision_dns is True:
        #     _log.info('Attempting to update Route53 DNS for instance')
        #     _update_dns(m, i, name)

        return True

    _log.debug('Instance {0} not provisioned. provision_enabled = False.'.format(i))
    return False


def main(options):
    """
    The main program function
    """

    if options['--debug'] is True:
        import logging
        _log.setLevel(logging.DEBUG)

    for key, value in iteritems(options):
        _log.debug('command-line options: {}: {}'.format(key, value))

    try:

        vpc_id = None
        m = mapper.AwsResourceMapper()

        # Check if we have a VPC to filter by then map it to an ID
        if options['--vpc-name']:
            vpc_id = m.vpc_name_to_id(options['--vpc-name'])
            _log.debug('Mapped VPC name {} to VPC-ID {}'.format(options['--vpc-name'], vpc_id))
            options['--vpc-id'] = vpc_id

        # If we have a vpc-id instead then use it
        if options['--vpc-id']:
            vpc_id = options['--vpc-id']

        from os.path import expanduser
        file_params = expanduser('{}/{}/stack_config.yaml'.format(options['--cb-root'], options['--envname']))
        _log.info('Checking for stack config at {}'.format(file_params))
        file_instances = expanduser('{}/{}/instances.md'.format(options['--cb-root'], options['--envname']))
        _log.info('Checking for instance listing at {}'.format(file_instances))

        # Now check for the necessary files in the conf-dir
        if os.path.exists(file_params) and os.path.exists(file_instances):

            _log.info('Reading DNS suffix from stack config')
            stack_config = get_config_from_file(file_params)
            _log.info('Loading Instances File {0}'.format(file_instances))
            instances_to_build = get_config_from_file(file_instances)

            subnet_names = [x[_cCOL_SUBNET_NAME] for x in instances_to_build]
            sg_names = [x[_cCOL_SECURITY_GROUPS] for x in instances_to_build]
            ami_ids = [x[_cCOL_AMI_ID] for x in instances_to_build]
            iam_roles = [x[_cCOL_IAM_ROLE] for x in instances_to_build]

            _log.info('Validating contents of instance table')
            if _validate_vpc(m, subnet_names=subnet_names, sg_names=sg_names, ami_ids=ami_ids, iam_roles=iam_roles) is False:
                _log.error('Configuration validation failed. Aborting')
                clean_up(-1)

            # Trigger provisioning of instances
            num_instances_provisioned = _provision_instances(
                m,
                instances_to_build,
                options=options,
                keyname=stack_config['default_key_name'],
                dns_suffix=stack_config['dns_suffix']
            )
            _log.info('Done. {0} new instances provisioned'.format(num_instances_provisioned))


    except KeyboardInterrupt:
        _log.info("Interrupted.. (try with -v for verbose mode if you need more info)")
        clean_up(-1)

    except AssertionError, e:
        _log.warn(e)
        clean_up(-1)

    clean_up()


if __name__ == "__main__":

    try:
        options = docopt.docopt(__doc__)
        main(options)

    # Handle invalid options
    except docopt.DocoptExit as e:
        print(e.message)
